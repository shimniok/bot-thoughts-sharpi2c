{{      Title:    24lc16b EEPROM Driver     Author:    Jim Newman     Version:    1.0                         Initial Release     Revision History:      1.0         06/16/2011      Initial Release          Object Description:    The intent of this file is to test the i2c interface using the 24lc16b eeprom.     Method: start(scl_pin, sda_pin, frequency)                  Used to initialize the i2c object and to start the i2c interface    bus on the specified pins at the specified frequency.       scl_pin       - scl pin    sda_pin       - sda pin    frequency     - frequency of the i2c bus                    This object supports both 100KHz and 400KHz i2c bus                    frequencies.       return        - cog id plus 1        Method: stop       Used to shut down the i2c interface object                     - no parameters       return        - no returned value     Method: write_byte(address, data)       Used to write a single byte to the eeprom at the specified address.       address       - memory address at which the data byte will be written    data          - the data byte to be written to the eeprom       return        - ack from the eeprom                    1 if the eeprom sent an acknowledgement                    0 if the eeprom failed to acknowledgement       Method: read_byte(address)       Used to read a single byte from the eeprom at the specified address.       address       - memory address at which the data byte to be read       return        - the byte read from the eeprom     Method: write_block(address, block, count)       Used to write a block of bytes to the eeprom at the specified address.  A    maximum of 16 bytes        address       - memory address at which the first byte of data will be written    data          - the block of data bytes to be written to the eeprom    count         - the number of bytes from 1 to 16 that is to be written to the                    eeprom       return        - no return value          Method: read_block(address, block, count)       Used to read a block of bytes from the eeprom starting at the specified address.    A maximum of 16 bytes can be read.       address       - memory address at which the first byte of data to be read    data          - a pointer to the block of data where the data is to be written    count         - the number of bytes from 1 to 16 that is to be read from the                    eeprom       return        - no return value }}    OBJ                               i2c     : "i2c" PUB start(scl_pin, sda_pin, frequency) : results             results := i2c.init(scl_pin, sda_pin, frequency)  return resultsPUB stop  i2c.kill        PUB write_byte(address, data) : results | ack{  The address can go from $000 to $7ff.  Therefore, we need to mask off the upper  three bits and place them into the control byte to set the block address.  We  can then set the last eight bits to the address within the memory block.}  ack := 0  repeat until ack == 1            i2c.start              ack := i2c.write_byte($a0 | ((address & $700) >> 7))    i2c.write_byte(address & $0ff)   ack := i2c.write_byte(data)  i2c.stop  return ackPUB read_byte(address) : data | ack{  As with write_byte, the address can go from $000 to $7ff,  Therefore, we need to mask  off the upper three bits and place them into the control byte to set the block address.  We can then set the last eight bits to the address within the memory block.}             ack := 0    repeat until ack == 1           i2c.start                 ack := i2c.write_byte($a0 | ((address & $700) >> 7))    i2c.write_byte(address & $0ff)    i2c.start    i2c.write_byte($a1 | ((address & $700) >> 7))     data := i2c.read_byte(FALSE)                        ' single byte read    i2c.stop    return dataPUB write_block(address, block, count) : results | ack, cnt_addr, start_addr, wrt_num, num_written{  The intent of this routine is to write a block of data.  The challenge here is that  the address can not cross over a 16 byte boundary, $xxf to $xx0.  We need to prevent this  by making sure that the start address plus the number of bytes to be written do not  go over address $xxf.  If it will, then we need to first write the number of bytes  that will fit in the starting block and then write the rest of the bytes to the next  block.  Enhancements:  1.)  We presently have a maximum limit of 16 bytes to be written.  This is because       the 24lv16b can only write a maximum of 16 bytes at a time.  We could modify       this function to break the block writes into 16 bytes at a time so that the       user could use as large of a buffer as they like.  2.)  We presently don't check to see if the address wraps around from $7ff to $000.        We could add this detection and just stop after address $7ff.}  if count > 16                              ' make sure that we don't have more than 16 bytes                            count := 16                                                                    num_written := 0                            ' set a counter for the number of bytes written  start_addr := address  repeat     if ((start_addr & $00f) + (count - 1)) > $00f      wrt_num := ($10 - (start_addr & $00f))  ' we will need to make two block writes    else      wrt_num := count - num_written          ' everything should fit in this block write    cnt_addr := ((start_addr & $700) >> 7)    ' set the block address in the control byte     'term.str(string("start address = "))    'term.dec(start_addr)    'term.str(string(", bytes to write = "))    'term.dec(wrt_num)    'term.tx(13)    ack := 0    repeat until ack == 1                     ' wait until memory is ready      i2c.start                               ' sent start sequence      ack := i2c.write_byte($a0 | cnt_addr)   ' write control byte and get acknowledgement        i2c.write_byte(start_addr & $0ff)         ' write starting address lower eight bits    ack := i2c.write_block(block, wrt_num)    ' write block of data to memory    i2c.stop                                  ' send stop sequence    num_written += wrt_num                    ' save number of bytes written to memory    if num_written < count                    ' if we haven't written the full buffer yet...      start_addr += wrt_num                   '   set start address of next block      block := block + (wrt_num * 4)          '   update pointer to block of data to be written      wrt_num := count - wrt_num              '   calculate remaining number of bytes to write     else                                      ' if we have written everything      quit                                    '   break out of repeat loop      PUB read_block(address, block, count) : results | i, ack, cnt_addr, addr_start, read_num, num_read{  The intent of this routine is to read a block of data.  The concept is identical to the write  block procedure described above.    Enhancements:  1.)  We presently have a maximum limit of 16 bytes to be read.  We could modify       this function to break the block reads into 16 bytes at a time so that the       user could use as large of a buffer as they like.  2.)  We presently don't check to see if the address wraps around from $7ff to $000.       We could add this detection and just stop after address $7ff.}  if count > 16                              ' make sure that we don't have more than 16 bytes                            count := 16             cnt_addr := ((address & $700) >> 7)        ' set the block address in the control byte                     addr_start := (address & $0ff)             ' get the start address in the present block  if (addr_start + count) > $100             ' check to see if we need to go to the next block    read_num := count - (addr_start + count - $100)      ' address wraps around to next block  else    read_num := count                                    ' address does not wrap around to the next block                                                           num_read := 0                              ' set a counter for the number of bytes to read   repeat     ack := 0    'term.str(string("start address = "))    'term.dec(addr_start)    'term.str(string(", bytes to read = "))    'term.dec(read_num)    'term.tx(13)    repeat until ack == 1                     ' wait until memory is ready      i2c.start                               ' sent start sequence      ack := i2c.write_byte($a0 | cnt_addr)   ' write control byte and get acknowledgement        i2c.write_byte(addr_start)                ' write starting address    i2c.start    i2c.write_byte($a1 | cnt_addr)     ack := i2c.read_block(block, read_num, FALSE)    ' read block of data from memory    i2c.stop                                  ' send stop sequence    num_read += read_num                      ' save number of bytes read from memory    if num_read <> count                      ' if we haven't read the full number of bytes yet...      addr_start := 0                         '   set start address of next block      block := block + (read_num * 4)         '   update pointer to block to save read bytes      read_num := count - read_num            '   calculate remaining number of bytes to read      cnt_addr := (cnt_addr + 2) & $0e        '   update block address for control byte    else                                      ' if we have read everything      quit{{Copyright(c) 2011 - Jim NewmanPermission is hereby granted, free of charge, to any person obtaining a copy of thissoftware and associated documentation files (the "Software"), to deal in the Softwarewithout restriction, including without limitation the rights to use, copy, modify,merge, publish, distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject to the followingconditions:The above copyright notice and this permission notice shall be included in all copiesor substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR APARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHTHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OFCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWAREOR THE USE OR OTHER DEALINGS IN THE SOFTWARE. }}