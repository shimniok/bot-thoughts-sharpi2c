{{   Title:    I2C Driver     Author:    Jim Newman     Version:    1.0                         Initial Release     Revision History:    1.0         06/16/2011      Initial Release         Object Description:    The intent of this object is to implement a pasm based I2C interface.    This was done as a learning experience for Spin, PASM, and the    Propeller, but primarily for PASM.       The following is a listing of each method in this object with a    brief description of the object and its parameters.  It also lists    any returned results.     Method: init(scl_pin, sda_pin, frequency)       Used to initialize the i2c object and to start the i2c interface    bus on the specified pins at the specified frequency.       scl_pin       - scl pin    sda_pin       - sda pin    frequency     - frequency of the i2c bus                    This object supports both 100KHz and 400KHz i2c bus                    frequencies.       return        - cog id plus 1     Method: kill       Used to shut down the i2c interface object                     - no parameters       return        - no returned value     Method: start       Used to generate an i2c start sequence on the i2c bus.                       - no parameters          return        - no returned value     Method: write_byte(data_byte)       Used to write a single byte on the i2c bus.       data_byte     - lower byte of long will be written to the i2c bus.       return        - 1 if write succeeded                    0 if write failed     Method: write_block(data_block, count)       Used to write a block of data to the i2c bus.       data_block    - a pointer to the first long in hub memory that                    contains the data to be written to the i2c bus                    (lower byte of long will be written)    count         - number of bytes to be written         return        - 1 if block write succeeded                    0 if block write failed     Method: read_byte(do_ack)       Used to read a single byte from the i2c interface bus.       do_ack        - TRUE if not the last byte to be read                    FALSE if this is the last byte to be read       return        - data read from i2c bus                      Method: read_block(data_block, count, do_ack)       Used to read a block of data from the i2c bus.       data_block    - a pointer to the first long in hub memory where                    the data to be written that is read from the i2c                    bus                    (lower byte of long will be written)    count         - number of bytes to be read     do_ack        - FALSE no ack will be written on the last byte                    read from the i2c bus                    TRUE an ack will be written to the i2c bus after                    every read.             Method: stop       Used to generate an i2c stop sequence on the i2c bus.                       - no parameters          return        - no returned value     Future Enhancements (limitations, issues, problems, ...):       1.  This object is very inefficient when it comes to memory management.        Most of the methods use longs instead of bytes to transfer data between        hub memory and the i2c interface object.        Key enhancement is to rewrite the object to use bytes instead of longs        where appropriate.    2.  This i2c interface should be able to support a single call to generate        a start-control-data-stop sequence.  With some simple modifications,        this i2c interface should be able to support a start-control-data-read-        stop sequence.  That means that with a single call to the i2c bus, we        should be able to either write a sequence of data or read a sequence of        data.    3.  There is an absolute minimum of error checking being done to improve        performance.    4.  There is no time-out in case the i2c device does not respond.  Therefore        this object is  blocking.    5.  There is a timing limitation in the implementation of the block read         that prevents the i2c driver from going much more that 400KHz.  The read        could be rewritten to remove this timing limitation so that the driver        can go faster.    6.  I could save additional memory by making the write and read count be part        of the flags register.    7.  This driver was written and tested using the propeller running at 80MHz.        I'm not sure what will happen if the clock frequency is changed.                    }}CON  start_flag  =  $001  write_flag  =  $002  read_flag   =  $004  stop_flag   =  $008  ack_flag    =  $010     VAR  long  cog  long  scl  long  sda  long  delay_cnt  long  flags  long  data_ptr  long  count_ptr  long  ack               long  debug    { The driver uses a flag register in hub memory to trigger the  i2c driver to perform a function.  The flag register can be  expanded to add additional functionality.      flags bit definitions:        b0            start        b1            write byte        b2            read byte        b3            stop         b4            ack} PUB init(scl_pin, sda_pin, frequency) : results  scl := scl_pin        sda := sda_pin  delay_cnt := clkfreq/frequency    kill                               results := cog := cognew(@init_, @scl) + 1           PUB kill  if cog    cogstop(cog~ - 1)  cog := 0PUB start      flags := start_flag  repeat until flags == 0  PUB write_byte(data_byte)  return write_block(@data_byte, 1) PUB write_block(data_block, count)  if count < 1    return FALSE   count_ptr := count  data_ptr := data_block   flags := write_flag  repeat until flags == 0    return ack PUB read_byte(do_ack) : results | data_byte    read_block(@data_byte, 1, do_ack)  results := data_byte PUB read_block(data_block, count, do_ack)  if count < 1    return FALSE  count_ptr := count  data_ptr := data_block   if do_ack == TRUE    flags := read_flag | ack_flag       ' read multi-byte sequence and not last byte so ack  else    flags := read_flag & !ack_flag      ' read single byte or last byte of multi-byte sequence so nack  repeat until flags == 0  return TRUEPUB stop              flags := stop_flag  repeat until flags == 0DAT              org       0              init_         mov       stack, par              ' get pointer to scl              rdlong    regA, stack             ' get pin number for scl                      mov       scl_mask, #1            ' initialize scl bit position              shl       scl_mask, regA          ' shift scl to proper bit position               andn      dira, scl_mask          ' initialize scl as input              add       stack, #4               ' get pointer to sda              rdlong    regA, stack             ' get pin number for sda              mov       sda_mask, #1            ' initialize sda bit position              shl       sda_mask, regA          ' shift sda to proper bit position              andn      dira, sda_mask          ' initialize sda as input              add       stack, #4               ' get pointer to delay_cnt              rdlong    regA, stack             ' get delay_cnt              mov       q_freq, regA            ' save delay_cnt in delay              shr       q_freq, #2              ' we want to divide the delay by 4              add       stack, #4               ' get status flags address               mov       flags_addr, stack       ' save pointer to status flags                add       stack, #4               ' get data pointer              mov       data_ptr_, stack        ' save data pointer                add       stack, #4               ' get count pointer                 mov       count_ptr_, stack       ' save count_pointer              add       stack, #4               ' get ack address              mov       ack_addr, stack         ' save pointer to data                     add       stack, #4               ' get pointer to debug output long              mov       debug_addr, stack       ' save memory address of debug output long               'wrlong    q_freq, debug_addr      ' this is how you use debug_addr                                     mov       regA, #0                                            wrlong    regA, data_ptr_         ' clear data                      wrlong    regA, flags_addr        ' clear flags              jmp       #monitormonitor       rdlong    flags_, flags_addr wz        if_z  jmp       #monitor                   and       flags_, #start_flag wz, nr        if_nz call      #start_seq_              and       flags_, #write_flag wz, nr        if_nz call      #write_seq              and       flags_, #read_flag wz, nr        if_nz call      #read_seq              and       flags_, #stop_flag wz, nr        if_nz call      #stop_seq_              mov       flags_, #0                  wrlong    flags_, flags_addr              jmp       #monitorstart_seq_    or        dira, sda_mask          ' set sda as an output                or        outa, sda_mask          ' set sda high               mov       delay, cnt              ' we want to delay 1/4 period              add       delay, q_freq              waitcnt   delay, q_freq                      or        dira, scl_mask          ' set scl as an output               or        outa, scl_mask          ' set scl high                 waitcnt   delay, q_freq           ' delay 1/4 period                                                                            andn      outa, sda_mask          ' set sda low to indicate start               waitcnt   delay, q_freq           ' we want to delay another 1/4 period                                                                 andn      outa, scl_mask          ' set scl low to finish start                 waitcnt   delay, q_freq           ' we want to delay another 1/4 periodstart_seq__ret retwrite_seq     rdlong    tmp_ptr_, data_ptr_     ' get pointer to data                 rdlong    count_, count_ptr_      ' get number of bytes to write              mov       ack_, #1                ' set acknowledgement to true (successful):byte_loop    rdlong    data_, tmp_ptr_         ' get data to write              mov       bit_mask, #$80          ' set mask to track each bit to write                mov       delay, cnt              ' set-up delay                   add       delay, q_freq                                                :bit_loop     waitcnt   delay, q_freq           ' delay 1/4 period               and       data_, bit_mask wz, nr  ' set data        if_nz or        outa, sda_mask          '   to a high        if_z  andn      outa, sda_mask          '   to a low              waitcnt   delay, q_freq           ' delay 1/4 period              or        outa, scl_mask          ' set clock high              waitcnt   delay, q_freq           ' delay 1/2 period              waitcnt   delay, q_freq              andn      outa, scl_mask          ' set clock low                         shr       bit_mask, #1            ' shift bit mask to next position in byte                tjnz      bit_mask, #:bit_loop    ' if mask is not cleared, do next bit in byte        :ack          andn      dira, sda_mask          ' set sda as input              waitcnt   delay, q_freq           ' delay 1/2 period                 waitcnt   delay, q_freq           '               or        outa, scl_mask          ' set clock high              waitcnt   delay, q_freq           ' delay 1/4 period                mov       regA, ina               ' get acknowledgement              and       regA, sda_mask wz       ' test acknowledgement           if_nz mov       ack_, #0                ' ack did not occur, clear returned value                waitcnt   delay, q_freq           ' delay 1/4 period                andn      outa, scl_mask          ' set clock low              andn      outa, sda_mask          ' set sda low to prevent glitch              or        dira, sda_mask          ' set sda back to output              add       tmp_ptr_, #4            ' point to next byte to write              djnz      count_, #:byte_loop                     wrlong    ack_, ack_addr          ' save ack                                               write_seq_ret retread_seq      rdlong    tmp_ptr_, data_ptr_     ' get pointer to data                 rdlong    count_, count_ptr_      ' get number of bytes to write:byte_loop    andn      dira, sda_mask          ' set sda to input               mov       data_, #0                 mov       loop_cnt, #8              mov       delay, cnt              add       delay, q_freq:bit_loop     waitcnt   delay, q_freq           ' delay 1/4 period                                                  shl       data_, #1              or        outa, scl_mask          ' set clock high              waitcnt   delay, q_freq           ' delay 1/4 period              and       sda_mask, ina wz, nr    ' test data input bit                    if_nz add       data_, #1               ' set bit in output data if input bit was high                waitcnt   delay, q_freq           ' delay 1/4 period              andn      outa, scl_mask          ' set clock low                 waitcnt   delay, q_freq           ' delay 1/4 period                djnz      loop_cnt, #:bit_loop                                 ' if read count is not equal to 1, then we know that we must send an ack                mov       regA, #1                ' use regA to hold 32 bit value              cmp       count_, regA wz, nr     ' see if this is not the last byte to read        if_nz jmp       #:skip                  ' not last byte so skip check of ack_flag               ' at this point, count_ is equal to 1              ' when read count is equal to 1 and ack_flag is set, send an ack              ' when read count is equal to 1 but ack_flag is not set, then we want to send an nack                           and       flags_, #ack_flag wz, nr ' see if we generate an ack or nack:skip   if_nz andn      outa, sda_mask          ' generate an ack by setting sda low        if_z  or        outa, sda_mask          ' generate a nack              or        dira, sda_mask          ' set sda back to output               waitcnt   delay, q_freq           ' delay 1/4 period                or        outa, scl_mask          ' set clock high                                   waitcnt   delay, q_freq           ' delay 1/4 period               waitcnt   delay, q_freq           ' delay 1/4 period              andn      outa, scl_mask          ' set clock low                                       waitcnt   delay, q_freq           ' delay 1/4 period                    wrlong    data_, tmp_ptr_         ' write data to caller              add       tmp_ptr_, #4                                djnz      count_, #:byte_loop                                   read_seq_ret  ret                                               stop_seq_     or        dira, sda_mask          ' set sda as output              andn      outa, sda_mask          ' set sda low                             mov       delay, cnt              ' set-up delay                                         add       delay, q_freq              waitcnt   delay, q_freq           ' delay 1/4 period                            or        outa, scl_mask          ' set scl high to indicate stop               waitcnt   delay, q_freq           ' we want to delay another 1/4 period              or        outa, sda_mask          ' set sda high              waitcnt   delay, q_freq           ' delay 1/4 period              'andn      dira, scl_mask          ' set scl as input              andn      dira, sda_mask          ' set sda as input   stop_seq__ret ret                                           q_freq        res       1 stack         res       1   scl_mask      res       1sda_mask      res       1 delay         res       1flags_        res       1flags_addr    res       1data_ptr_     res       1count_ptr_    res       1ack_          res       1ack_addr      res       1debug_addr    res       1          regA          res       1      bit_mask      res       1data_         res       1count_        res       1  loop_cnt      res       1tmp_ptr_      res       1              FIT       496{{Copyright(c) 2011 - Jim NewmanPermission is hereby granted, free of charge, to any person obtaining a copy of thissoftware and associated documentation files (the "Software"), to deal in the Softwarewithout restriction, including without limitation the rights to use, copy, modify,merge, publish, distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject to the followingconditions:The above copyright notice and this permission notice shall be included in all copiesor substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR APARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHTHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OFCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWAREOR THE USE OR OTHER DEALINGS IN THE SOFTWARE. }}